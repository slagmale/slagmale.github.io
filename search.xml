<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux系统中Centos安装及配置]]></title>
    <url>%2F2018%2F04%2F23%2FLinux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[1.安装虚拟机+操作系统 : VMware Centos 2.设置基础环境三要素：IP 主机名 映射（包括本地） 3.网络配置 ：设置DNS解析 PING通外网 4.创建普通用户 5.设置sudo权限 6.禁用防火墙 7.卸载系统自带的Open jdk并配置Oracle jdk 我用的是VM ware12版本 Centos6.x 比较稳定。安装完成后进行相关的配置 虚拟机设置1.打开编辑虚拟机设置，设置相关设备（内存 处理器 硬盘）。网络连接使用NAT模式，用于共享主机的ip地址。 2.配置虚拟网络编辑器。打开VM ware软件上方的编辑选项点击进入。修改VMnet 8 适配器网段地址以及在NAT设置中设置网关。 基本环境的配置修改主机名12345678910查看主机名 在命令行界面输入 hostname临时修改 hostname bigdata-training01.hd.com永久修改/etc/sysconfig/network 如果没有即时生效 命令行输入 init 6 重启虚拟机 vim /etc/sysconfig/network 查看主机名 进入network文件编辑 修改主机名 配置网络1234567891011121314151617181920212223配置IP地址 IP地址:必须与虚拟机NAT模式下分配的IP地址同网段 子网掩码:必须与虚拟机NAT模式下分配的IP地址的子网掩码相同配置连接外网 网关：必须使用NAT模式提供网关，一般默认是.2 DNS：域名解析服务器，建议与网关地址一致，也可以使用一些公共的DNS地址（8.8.8.8）配置网络方式 1.图形化界面配置(比较方便) 2.命令行方式：修改网卡配置文件 vi /etc/sysconfig/networkscripts/ifcfg-eth0 修改完成后重启网络服务 service network restart 这里使用图形化界面配置 网络映射（局域网内）12345修改配置文件：/etc/hosts在文件里加入ip地址 和 对应设置的域名修改windows的本地映射，这样就可以通过本机可以ping通虚拟机的域名 主机名 C:\Windows\System32\drivers\etc\hosts注意，如果host修改失败，可以先copy到桌面，修改完然后替换原有host文件 1（要切换到root下进行操作） 添加删除用户1234useradd usernamepasswd username #给用户设置密码userdel username（要切换到root下进行操作） 添加一个用户aaa 给该用户设置密码 （命令行下输入密码时不会显示 ） 删除用户 并在home目录下删除该用户的文件夹 配置IP地址和主机名映射123vim /etc/hosts进入后在行尾添加 ip地址 域名 主机名 3个值例如：192.168.59.200 bigdata.huadian.com bigdata 添加映射 设置权限输入如下命令 进入后 键盘输入/root搜索 找到下面的语句 并设置用户权限 关闭防火墙可以先看一下防火墙的状态 当前关闭（重启虚拟机后又会失效）：$ sudo service iptables stop永久关闭：$ sudo chkconfig iptables off 出现如下信息说明关闭成功 规划Linux系统目录结构12345678910以系统 /opt 目录为主安装软件包，在该目录下创建以下4个文件夹 /opt /datas 测试数据 /softwares 软件包 /modules 软件安装目录 /tools 开发IDE及工具 安装JDK1234567891011121314151617181920212223242526272829-a. 卸载系统自带的OpenJDK 查看安装的JDK $ sudo rpm -qa|grep java 卸载JDK $ sudo rpm -e --nodeps java-1.6.0-openjdk-1.6.0.0-1.50.1.11.5.el6_3.x86_64 tzdata-java-2012j-1.el6.noarch java-1.7.0-openjdk-1.7.0.9-2.3.4.1.el6_3.x86_64 -b. Linux系统自带上传下载软件 $ sudo yum install -y lrzsz 其中 rz: 上传文件 sz: 表示下载 -c. 安装JDK 在Linux安装JDK类似于Windows绿色软件的安装，直接解压，配置环境变量即可。 - 使用rz上传软件包至/opt/softwares - 解压到/opt/modules $ chmod u+x jdk-8u91-linux-x64.tar.gz ##给压缩包添加执行权限 进行解压 因为我上传后没有执行权限 $ tar -zxf jdk-8u91-linux-x64.tar.gz -C /opt/modules/ - 配置系统环境变量 $ sudo vim /etc/profile 在文件最后增加如下内容： # JAVA HOME export JAVA_HOME=/opt/modules/jdk1.8.0_91 export PATH=$&#123;PATH&#125;:$&#123;JAVA_HOME&#125;/bin 使其生效 $ source /etc/profile 验证 $ java -version]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis5大常用数据类型]]></title>
    <url>%2F2018%2F04%2F22%2FRedis%205%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[##存储格式 ##基本用法 通过Jedis(封装了redis的Java客户端)对redis进行操作。 Jedis工具类1234567891011121314151617181920212223242526272829303132public class JedisPoolUtil &#123; private static JedisPool pool = null; static &#123; //加载配置文件 InputStream in = JedisPoolUtil.class.getClassLoader().getResourceAsStream("redis.properties"); Properties pro = new Properties(); try &#123; pro.load(in); &#125; catch (IOException e) &#123; e.printStackTrace(); System.out.println("加载文件失败"); &#125; JedisPoolConfig poolConfig = new JedisPoolConfig(); //最大连接数 poolConfig.setMaxTotal(Integer.parseInt( pro.get("redis.maxTotal").toString())); //最大空闲连接数 poolConfig.setMaxIdle(Integer.parseInt( pro.get("redis.maxIdle").toString())); //最小空闲连接数 poolConfig.setMinIdle(Integer.parseInt( pro.get("redis.minIdle").toString())); pool = new JedisPool(poolConfig, pro.get("redis.url").toString(),Integer.parseInt( pro.get("redis.port") .toString())); &#125; public static Jedis getJedis()&#123; return pool.getResource(); &#125; public static void release(Jedis jedis)&#123; if(null != jedis)&#123; jedis.close(); &#125; &#125;&#125; ###redis配置文件 12345redis.maxTotal=100redis.maxIdle=30redis.minIdle=10redis.url=192.168.202.200 redis.port=6379 ###String 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class StringTest &#123; public Jedis jedis = JedisPoolUtil.getJedis(); @Test //添加和获取 public void fun()&#123; jedis.set("num","1"); System.out.println(jedis.get("num")); &#125; @Test //删除值 public void fun1()&#123; jedis.del("num"); System.out.println(jedis.get("num")); &#125; @Test //自减和自减 public void fun2()&#123; jedis.set("num","1"); System.out.println(jedis.get("num")); jedis.decr("num"); System.out.println(jedis.get("num")); jedis.incr("num"); jedis.incr("num"); System.out.println(jedis.get("num")); &#125; @Test //加上/减去 一个数 //incrBy 返回的是修改之后的值如果原值是字符串不是数字，则会抛出异常 public void fun3()&#123; Long num = jedis.incrBy("num", 3); System.out.println(num); jedis.decrBy("num",10); System.out.println(jedis.get("num")); jedis.set("name","caopengfei"); //jedis.decrBy("name",1); &#125; @Test //字符串拼接 public void fun4()&#123; Long len = jedis.append("name", "123"); System.out.println(len); System.out.println(jedis.get("name")); &#125;&#125; ###Hash 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283public class HashTest &#123; public Jedis jedis = JedisPoolUtil.getJedis(); // hash 操作的是map对象// 适合存储键值对象的信息 @Test //存值 参数第一个变量的名称， map键名(key)， map键值(value)// 调用hset public void fun() &#123; Long num = jedis.hset("hash1", "username", "caopengfei"); System.out.println(num); String hget = jedis.hget("hash1", "username"); System.out.println(hget); &#125; @Test //也可以存多个key// 调用hmset public void fun1() &#123; Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put("username", "caopengfei"); map.put("age", "25"); map.put("sex", "男"); String res = jedis.hmset("hash2", map); System.out.println(res);//ok &#125; @Test //获取hash中所有的值 public void fun2() &#123; Map&lt;String, String&gt; map2 = new HashMap&lt;String, String&gt;(); map2 = jedis.hgetAll("hash2"); System.out.println(map2); &#125; @Test// 删除hash中的键 可以删除一个也可以删除多个，返回的是删除的个数 public void fun3() &#123; Long num = jedis.hdel("hash2", "username", "age"); System.out.println(num); Map&lt;String, String&gt; map2 = new HashMap&lt;String, String&gt;(); map2 = jedis.hgetAll("hash2"); System.out.println(map2); &#125; @Test //增加hash中的键值对 public void fun4() &#123; Map&lt;String, String&gt; map2 = new HashMap&lt;String, String&gt;(); map2 = jedis.hgetAll("hash2"); System.out.println(map2); jedis.hincrBy("hash2", "age", 10); map2 = jedis.hgetAll("hash2"); System.out.println(map2); &#125; @Test //判断hash是否存在某个值 public void fun5() &#123; System.out.println(jedis.hexists("hash2", "username")); System.out.println(jedis.hexists("hash2", "age")); &#125; @Test //获取hash中键值对的个数 public void fun6() &#123; System.out.println(jedis.hlen("hash2")); &#125; // 获取一个hash中所有的key值 @Test public void fun7() &#123; Set&lt;String&gt; hash2 = jedis.hkeys("hash2"); System.out.println(hash2); &#125; // 获取所有的value值 @Test public void fun8() &#123; List&lt;String&gt; hash2 = jedis.hvals("hash2"); System.out.println(hash2); &#125;&#125; ###List 123456789101112131415161718192021222324252627282930313233public void testList()&#123; jedis.flushDB(); System.out.println("===========添加一个list==========="); jedis.lpush("collections", "ArrayList", "Vector", "Stack", "HashMap", "WeakHashMap", "LinkedHashMap"); jedis.lpush("collections", "HashSet"); jedis.lpush("collections", "TreeSet"); jedis.lpush("collections", "TreeMap"); System.out.println("collections的内容："+jedis.lrange("collections", 0, -1));//-1代表倒数第一个元素，-2代表倒数第二个元素 System.out.println("collections区间0-3的元素："+jedis.lrange("collections",0,3)); System.out.println("==============================="); // 删除列表指定的值 ，第二个参数为删除的个数（有重复时），后add进去的值先被删，类似于出栈 System.out.println("删除指定元素个数："+jedis.lrem("collections", 2, "HashMap")); System.out.println("collections的内容："+jedis.lrange("collections", 0, -1)); System.out.println("删除下表0-3区间之外的元素："+jedis.ltrim("collections", 0, 3)); System.out.println("collections的内容："+jedis.lrange("collections", 0, -1)); System.out.println("collections列表出栈（左端）："+jedis.lpop("collections")); System.out.println("collections的内容："+jedis.lrange("collections", 0, -1)); System.out.println("collections添加元素，从列表右端，与lpush相对应："+jedis.rpush("collections", "EnumMap")); System.out.println("collections的内容："+jedis.lrange("collections", 0, -1)); System.out.println("collections列表出栈（右端）："+jedis.rpop("collections")); System.out.println("collections的内容："+jedis.lrange("collections", 0, -1)); System.out.println("修改collections指定下标1的内容："+jedis.lset("collections", 1, "LinkedArrayList")); System.out.println("collections的内容："+jedis.lrange("collections", 0, -1)); System.out.println("==============================="); System.out.println("collections的长度："+jedis.llen("collections")); System.out.println("获取collections下标为2的元素："+jedis.lindex("collections", 2)); System.out.println("==============================="); jedis.lpush("sortedList", "3","6","2","0","7","4"); System.out.println("sortedList排序前："+jedis.lrange("sortedList", 0, -1)); System.out.println(jedis.sort("sortedList")); System.out.println("sortedList排序后："+jedis.lrange("sortedList", 0, -1));&#125; Set12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** Set集合，和List类的区别就是* set中不会出现重复的数据* 他可以进行聚合操作效率比较高* 其余的操作基本上和list相同** */public class SetTest &#123; public Jedis jedis = JedisPoolUtil.getJedis(); @Test /*添加元素删除元素*/ public void fun()&#123; Long num = jedis.sadd("myset", "a", "a", "b","abc"); System.out.println(num); &#125; @Test /*获得元素*/ public void fun1()&#123; Set&lt;String&gt; myset = jedis.smembers("myset"); System.out.println(myset); &#125; @Test /*移除元素*/ public void fun2()&#123; jedis.srem("myset","a","b"); Set&lt;String&gt; myset = jedis.smembers("myset"); System.out.println(myset); &#125; @Test //判断是否这个set中存在某个值 public void fun3()&#123; Boolean sismember = jedis.sismember("myset", "a"); System.out.println(sismember); &#125; @Test //获得A-B 获得差集合 public void fun4()&#123; jedis.sadd("myset1","123","32","abc","def","123456","sdfasd"); jedis.sadd("myset2","abc","345","123","fda"); Set&lt;String&gt; sdiff = jedis.sdiff("myset1", "myset2"); System.out.println(sdiff); &#125; @Test //获得交集 public void fun5()&#123; Set&lt;String&gt; sinter = jedis.sinter("myset1", "myset2"); System.out.println(sinter); &#125; @Test// 获得并集合 public void fun6()&#123; Set&lt;String&gt; sunion = jedis.sunion("myset1", "myset2"); System.out.println(sunion); &#125; @Test// 成员数量 public void fun7()&#123; System.out.println(jedis.scard("myset1")); &#125; @Test// 获得随机的一个成员 public void fun8()&#123; System.out.println(jedis.srandmember("myset1")); &#125; @Test// 将相差的成员放到一个新的set中同理交集和并集都可以后面均// 加上一个store即可// 并返回新的长度 public void fun9()&#123; System.out.println(jedis.sdiffstore("myset3","myset1","myset2")); System.out.println(jedis.smembers("myset3")); &#125;&#125; SortedSet123456789101112131415161718192021222324/*和set极为的类似，他们是字符串的集合，没有重复的数据差别是sortedset每个成员中都会有一个分数（score）与之关联，redis正是通过分数来为集合中的成员进行从小到大的排序sortedset中数据必须单一但是他的score可以是重复的 */public class SortedsetTest &#123; public Jedis jedis = JedisPoolUtil.getJedis();// 添加元素 @Test public void fun()&#123; jedis.zadd("mysort",100.0, "zhangsan"); jedis.zadd("mysort",200.0,"lisi"); jedis.zadd("mysort",50.0,"wangwu"); Map&lt;String ,Double&gt;map = new HashMap&lt;String ,Double&gt;(); map.put("mutouliu",70.0); jedis.zadd("mysort",map); Set&lt;String&gt; mysort = jedis.zrange("mysort", 0, -1); System.out.println(mysort); Set&lt;String&gt; mysort1 = jedis.zrange("mysort", 1, 2); System.out.println(mysort1); &#125;&#125;]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F04%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>同步github</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
